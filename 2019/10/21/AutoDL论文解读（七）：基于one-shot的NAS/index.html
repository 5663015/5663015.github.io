<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="机器学习个人网站">
  <meta name="author" content="Xudong Li">
  <meta name="keywords" content>
  <title>AutoDL论文解读（七）：基于one-shot的NAS - 贾维斯的小屋</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
<link rel="alternate" href="/atom.xml" title="贾维斯的小屋" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>贾维斯的小屋</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-book"></i>
                专栏
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/机器学习wiki/">
                    
                    机器学习wiki
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/数据结构与算法/">
                    
                    数据结构与算法
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/NAS专栏/">
                    
                    NAS专栏
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/PHM专栏/">
                    
                    PHM专栏
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/books/">
                <i class="iconfont icon-books"></i>
                书单
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/2019/03/22/留言板/">
                <i class="iconfont icon-comment"></i>
                留言板
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-images"></i>
                展示
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/resume/">
                    
                    学术主页
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/show/">
                    
                    作品展示
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/wenzhang.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                AutoDL论文解读（七）：基于one-shot的NAS
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-10-21 17:09">
      2019年10月21日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      90
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2 年前
                
              </p>
            
            <article class="markdown-body">
              <div class="note note-success">
            <p>自动化机器学习（AutoML）最近变得越来越火，是机器学习下个发展方向之一。其中的神经网络结构搜索（NAS）是其中重要的技术之一。人工设计网络需要丰富的经验和专业知识，神经网络有众多的超参数，导致其搜索空间巨大。NAS即是在此巨大的搜索空间里自动地找到最优的网络结构，实现深度学习的自动化。自2017年谷歌与MIT各自在ICLR上各自发表基于强化学习的NAS以来，已产出200多篇论文，仅2019年上半年就有100多篇论文。此系列文章将解读AutoDL领域的经典论文与方法，笔者也是刚接触这个领域，有理解错误的地方还请批评指正！</p><p><strong>此系列的文章列表：</strong></p><ul><li><a href="https://5663015.github.io/2019/09/30/AutoDL论文解读（一）：基于强化学习的开创性工作/" target="_blank" rel="noopener">AutoDL论文解读（一）：基于强化学习的开创性工作</a></li><li><a href="https://5663015.github.io/2019/10/08/AutoDL论文解读（二）：基于遗传算法的典型工作/" target="_blank" rel="noopener">AutoDL论文解读（二）：基于遗传算法的典型方法</a></li><li><a href="https://5663015.github.io/2019/10/10/AutoDL论文解读（三）：基于层或块的搜索/" target="_blank" rel="noopener">AutoDL论文解读（三）：基于块搜索的NAS</a></li><li><a href="https://5663015.github.io/2019/10/12/AutoDL论文解读（四）：权值共享的搜索/" target="_blank" rel="noopener">AutoDL论文解读（四）：权值共享的NAS</a></li><li><a href="https://5663015.github.io/2019/10/15/AutoDL论文解读（五）：可微分方法的NAS/" target="_blank" rel="noopener">AutoDL论文解读（五）：可微分方法的NAS</a></li><li><a href="https://5663015.github.io/2019/10/15/AutoDL论文解读（六）：基于代理模型的NAS/" target="_blank" rel="noopener">AutoDL论文解读（六）：基于代理模型的NAS</a></li><li><a href="https://5663015.github.io/2019/10/21/AutoDL论文解读（七）：基于one-shot的NAS/" target="_blank" rel="noopener">AutoDL论文解读（七）：基于one-shot的NAS</a></li></ul>
          </div>
<p>本篇介绍三篇论文：《SMASH: One-Shot Model Architecture Search through HyperNetworks》，《Understanding and Simplifying One-Shot Architecture Search》和《Single Path One-Shot Neural Architecture Search with Uniform Sampling》。</p>
<h1 id="一、SMASH-One-Shot-Model-Architecture-Search-through-HyperNetworks"><a href="#一、SMASH-One-Shot-Model-Architecture-Search-through-HyperNetworks" class="headerlink" title="一、SMASH: One-Shot Model Architecture Search through HyperNetworks"></a><strong>一、SMASH: One-Shot Model Architecture Search through HyperNetworks</strong></h1><h2 id="1、总览"><a href="#1、总览" class="headerlink" title="1、总览"></a><strong>1、总览</strong></h2><p>这篇论文作者通过训练一个辅助模型：超网络（HyperHet），去训练搜索过程中的候选模型，这个超网络动态地生成生成具有可变结构的主模型的权值。尽管这些生成的权重比固定的网络结构自由学习得到的权重更差，但是不同网络在早期训练中的相对性能(即与最优值的距离)为最优状态下性能提供了有意义的指导。作者同时开发了一个基于存储库（memory-back）读写的网络表示机制，来定义各种各样的网络结构。作者称此方法为SMASH（one-Shot Model Architecture Search through Hypernetworks）</p>
<h2 id="2、利用超网络的one-shot结构搜索"><a href="#2、利用超网络的one-shot结构搜索" class="headerlink" title="2、利用超网络的one-shot结构搜索"></a><strong>2、利用超网络的one-shot结构搜索</strong></h2><p>在SMASH中，我们的目标是根据一个网络的验证集性能对一组网络的性能进行排序，这个任务是通过超网络生成权重来完成的。在每个训练步，我们随机地采样一个网络结构，用超网络生成它的权重，然后训练这个网络。训练结束后，再随机采样一些网络，它们的权重是由超网络生成的，直接评估它们的性能。选择其中在验证集表现最好的网络，再正常地训练它的权重。SMASH由两个核心要点：（1）我们采样网络结构的方法；（2）给定抽样结构的权重的方法。对于第一点，作者提出了网络的存储库视图，允许将复杂的、分支的拓扑作为二值向量进行采样和编码。对于第二点，作者使用超网络，直接学习二值向量的结构编码到权重的映射。这里假设只要超网络生成了合理的权值，网络的验证集性能将与使用正常训练权值时的性能相关，而结构的差异是其性能变化的主要因素。</p>
<h2 id="3、定义Memory-Bank"><a href="#3、定义Memory-Bank" class="headerlink" title="3、定义Memory-Bank"></a><strong>3、定义Memory-Bank</strong></h2><p>为了能探索非常广阔搜索的空间，也为了能将网络结构简单地编码成向量输入到超网络中，作者提出了网络的存储库视图。这个方法将网络视为一组可以读写的存储库（初始的张量为0），每一层是一个操作，这个操作从存储库的子集中读取数据，修改数据，然后将它写入另一个存储库子集。对于一个单分支结构，网络有一个大的存储库，它在每个操作上对其进行读写（对于ResNet是相加）。DenseNet这样的分支架构从所有以前写入的存储库读取数据，并将数据写入空的存储库，而FractalNet有更复杂的读写模式，见下图：<br><img src="https://img-blog.csdnimg.cn/2019101712391345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这里一个基本的网络结构包括多个block，在给定特征图下每个block有多个存储库，特征图大小依次减半。下采样是通过1x1卷积和平均池化完成的，1x1卷积和输出层的权重是自由学习到的，而不是超网络生成的。示意图如下所示：<br><img src="https://img-blog.csdnimg.cn/20191017124604975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在采样结构时，每个block的存储库的的数目和通道数目是随机采样的。当定义一个block里的每层时，我们随机选择读写模式和作用在读取的数据上的操作。当从多个存储库读取读取时，我们沿通道这个轴连接数据，写入存储库时，将此数据与写入存储库中数据相加。在这篇论文中，作者只从一个block里的存储库中读写，虽然也可以从其他block里的存储库中读写。</p>
<p>每个操作包含一个1x1卷积（降低输入通道数目），然后接带非线性变换的可变数量的卷积，如上图（a）中所示，随机选择四个卷积中的哪个被激活，以及它们的过滤器大小、膨胀系数、组数和输出单元数。这里的1x1卷积是由超网络生成的（上面也有一个1x1卷积，那个是用来和池化一块来减小特征图高宽的，是自由学习到的，和这里的不一样）。为了确保可变深度，每个块都学习一个含4个卷积的集合，并在一个块内的所有操作中共享它。这里限制了最大的滤波器大小和输出单元的数目，当采样的操作使用的值小于其最大值时，我们简单地将张量切片至所需的大小。固定的变换卷积和输出层根据传入的非空存储库的数量使用相同的切片。</p>
<p>作者力求最小化学习到的静态参数的数量，将网络的大部分容量放在超网络中。这一目标的一个显著结果就是，我们只在下采样层和输出层之前使用BatchNorm，因为特定层的运行统计量很难动态生成。这里作者采用一个简化版的WeightNorm，每个生成的1 x1滤波器除以其欧几里得范数（而不是每个通道单单独规范化），用在固定结构的网络中仅导致小精度下降。操作中其他卷积是没有标准化的。</p>
<h2 id="4、学习结构到权重的映射"><a href="#4、学习结构到权重的映射" class="headerlink" title="4、学习结构到权重的映射"></a><strong>4、学习结构到权重的映射</strong></h2><p>超网络是用来给另一个网络参数化权重的，那个网络就是主网络（main network）。对于参数是$H$的静态超网络，主网络的权重$W$是一个已学习到的嵌入$z$的函数（例如感知机），因此，学习到的权值的数量通常小于主网络权值的完整数量。对于动态超网络，权值$W$的生成取决于网络输入$x$，或者对于循环神经网络，则取决于当前输入$x_{t}$和先前的隐藏状态$h_{t-1}$。</p>
<p>基于主网络结构$c$的编码，作者提出了一个动态超网络取生成权重$W$，目标是学习一个映射$W=H(c)$，也就是说给定$c$使其接近最优权值$W$，这样就可以根据使用超级网络生成的权重，得到验证集误差，并对每个$c$进行排序。</p>
<p>这里的超网络是全卷积的，这样输出张量$W$的维数就会随着输入$c$的维数而变化，这样我们就得到了标准格式BCHW的4D张量，批量大小为1，因此没有输出元素是完全独立的。这允许我们通过增加$c$的宽度或长度去改变主网络的深度和宽度。在这样的设计下，$W$的每个空间维度的切片都对应于$c$的一个特定子集。描述操作的信息被嵌入到相应的$c$的切片的通道维度中。</p>
<p>以下图为例，如果一个操作从存储库1,2，4中读取数据，然后写入到2,4中，然后相应的$c$的切片的第一、二、四个通道被填入1（表示读），切片的第六、八通道填入1（表示写）。其他的操作在余下的通道中用同样1-hot的方式编码。我们只根据操作的输出单元的数量对$c$的宽度进行编码，所以没有与$W$的任何元素对应的$c$元素都是空的。<br><img src="https://img-blog.csdnimg.cn/20191017152952440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>上述方案的一个朴素实现是让$c$的大小等于$W$的大小，或者让超网络用上采用去产生更多的元素。但作者发现这样的效果很差，取而代之的是采用一种基于通道的权重压缩方案，该方案减小了$c$的大小，并使超级网络的表示能力与主要网络的表示能力成比例。作者使$c$的空间范围等于$W$大小的一部分$k$，在超网络的输出处放$k$个单元，然后将得到的$1\times k \times height \times width$重塑成要求的$W$的大小。$k$定为$DN^{2}$，$N$是最小的存储库大小，$D$是一个“深度压缩”超参数，表示$W$的多少个切片对应于$c$的一个切片。</p>
<p>标准的2D CNN的输入是$x \in \Bbb R^{B \times C \times H \times L}$，B,C,H,L分别是批大小、通道、高度、宽度。我们的嵌入张量是$c \in \Bbb R^{1 \times (2M+d_{max}) \times (N_{max}/N)^{2} \times n_{ch}/D}$，M是一个block里存储库的最大数目，$d_{max}$是最大的卷积膨胀率，$n_{ch}$是主网络所有1x1卷积输入通道数目的综合。条件嵌入（conditional embedding）$c$是一个每层用来读写的存储库的独热编码，它有$2M+d_{max}$个通道，前M个通道表示从哪些存储库中读取，下M个通道表示写入到哪些存储库中，最后$d_{max}$个通道是3x3卷积里膨胀率的独热编码。宽度这个维度表示每层的单元数目，长度这个维度表示网络深度，即输入通道的总数。这里将批大小保持为1，这样就不会有信号完全独立地通过超级网络传播。</p>
<p>超网络有$4DN^{2}$个输出通道，因此超网络的输出是$W=H(c) \in \Bbb R^{1 \times 4DN^{2} \times (N_{max}/N^{2})\times n_{ch}/D}$，然后重塑为$W \in \Bbb R^{N_{max} \times 4N_{max}n_{ch} \times 1 \times 1}$。我们一次生成整个主网络的权值，允许超网络根据邻近层的权值预测给定层的权值。超网络的接受域表示给定一个层，网络可以向上或向下多远来预测给定层的参数。当我们遍历主网络时，我们根据传入通道的数量沿其第二轴切片，并根据给定层的宽度沿第一轴切片。</p>
<h1 id="二、Understanding-and-Simplifying-One-Shot-Architecture-Search"><a href="#二、Understanding-and-Simplifying-One-Shot-Architecture-Search" class="headerlink" title="二、Understanding and Simplifying One-Shot Architecture Search"></a><strong>二、Understanding and Simplifying One-Shot Architecture Search</strong></h1><h2 id="1、总览-1"><a href="#1、总览-1" class="headerlink" title="1、总览"></a><strong>1、总览</strong></h2><p>这篇论文里作者也是认为模型之间的权重共享是个可行的方向，训练一个能够模拟搜索空间中任何架构的大型网络。一个简单的例子如下所示：<br><img src="https://img-blog.csdnimg.cn/20191017165558681.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>上图中，在网络的某个位置，有3x3卷积、5x5卷积或者最大池化三个操作可以选择，不同于分别训练三个模型，我们训练一个包括了这三个操作的模型（one-shot model），然后在验证阶段，我们选择性地剔除其中两个操作的输出，保留使预测准确率最高的操作。一个更复杂的例子，在一个网络中可能在很多位置上包含了很多不同的操作选择，搜索空间是随着选择数目指数地增长，而one-shot模型的大小只随选择数目线性增长。相同的权重可以用来评估很多不同的结构，极大地降低了计算量。</p>
<p>作者提出了这样的疑问，为什么不同的结构可以共享一个权重集合？one-shot模型仅在搜索过程中对结构的性能排序，搜索结束后表现最好的结构会被从头重新训练，但即使这样，固定的权重集合在非常广泛的结构集合里工作的很好，这也是违反直觉的。作者在这篇论文中目的是理解权重共享在NAS中所扮演的角色。作者发现，对于达到好的搜索结果，超网络和强化学习控制器都不是必须的。为此作者训练了一个大的one-shot模型，包含了搜索空间里的每个可能的操作。然后剔除一些操作，测量其对模型预测准确率的影响。作者发现网络自动将其能力集中在对产生良好预测最有用的操作上。剔除不太重要的操作对模型的预测的影响很小，而剔除很重要的操作对模型预测的影响很大。实际上，可以通过观察网络结构在训练集中无标签样例的行为，来预测网络在验证集上的准确率。</p>
<h2 id="2、搜索空间设计"><a href="#2、搜索空间设计" class="headerlink" title="2、搜索空间设计"></a><strong>2、搜索空间设计</strong></h2><p>为one-shot设计搜索空间需要满足以下几个要求：（1）搜索空间需要足够大来捕捉到多样的候选结构；（2）one-shot模型产生的验证集准确率必须能预测独立模型训练产生的精度；（3）在有限的计算资源下，one-shot模型需要足够小。下图给出了一个搜索空间的例子：<br><img src="https://img-blog.csdnimg.cn/20191017202414485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>它合并了关于网络结构和应用在网络中不同位置的操作的重要决策。在训练过程中，one-shot模型包括了三个不同的输入，这些输入被连接在一起。在评估阶段，它可以通过剔除Input 1和Input 3来模拟一个一个仅包含Input 2的网络。更一般地说，我们可以使能或禁止任何输入连接的组合。这样，搜索空间可以随着传入的跨连接数目指数级地增长，而one-shot模型大小只线性地增长。连接操作后面总是连着一个1x1卷积，使得无论有多少传入的跨连接，输出的滤波器数目都是常量。然后one-shot模型在1x1卷积的输出上应用不同的操作，将结果相加。在评估阶段，我们移除一些操作。上图中有4种操作：3x3卷积、5x5卷积、最大池化和Identity，但只有5x5卷积操作留了下来。这样的方法被用在更大的模型上，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191017204211237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这里的网络也是由多个一样的cell堆叠而成的，每个cell被分成了几个固定数目的choice block。一个choice block来自于前驱cell的输出或者同一cell的前驱choice block。这里作者设每个cell里有$N_{choice}=4$个choice block，每个choice block最多有5个可能的输入：两个来自前驱cell，三个来自同一cell的前驱choice block。每个choice block最多可以选择两个操作，可选择的操作有：identity，一对3x3可分离卷积，一对5x5可分离卷积，一对7x7可分离卷积，1x7卷积跟7x1卷积，最大池化，平均池化。</p>
<h2 id="3、训练one-shot模型"><a href="#3、训练one-shot模型" class="headerlink" title="3、训练one-shot模型"></a><strong>3、训练one-shot模型</strong></h2><p>one-shot模型是个大型的网络，用带动量的SGD训练，为了保证特定架构的one-shot模型精度与独立模型精度之间的良好关系，作者考虑了以下几个方面：</p>
<ul>
<li><p>互相适应的鲁棒性。如果直接训练整个one-shot模型，模型里的各部分会相互耦合。即使移除不重要的操作，也会造成模型预测精度的急剧下降，one-shot模型和独立模型之间的准确率的关系也会退化。为了解决这个问题，作者在训练one-shot模型时也包含了path dropout（我理解的是类似于dropout，起到了正则化的作用），对于每个batch，也随机地剔除一些操作。通过实验发现，一开始的时候不用path dropout，然后随着时间逐渐地增加dropout的几率，可以达到很好的效果。dropout的几率是$r^{1/k}$，$0&lt;r&lt;1$是模型的超参数，$k$是给定一个操作下进来路径的数目。然而dropout一个节点的所有输入的几率是常数，这里作者设为5%。在单个cell里，不同的操作使彼此独立地被剔除。如果一个模型包含多个cell，那在每个cell里通用的操作会被剔除。</p>
</li>
<li><p>训练模型的稳定性。作者一开尝试实验的时候发现one-shot的训练很不稳定，但是仔细地应用BN可以增加稳定性，作者使用了BN-ReLU-Conv这样的卷积顺序。在评估阶段要剔除某些操作，这会使每层batch的统计量改变，因为对于候选结构无法提前得知其batch统计量。因此批BN在评估时的应用方式与在训练时完全相同——动态计算batch的统计信息。作者还发现，训练one-shot模型时，如果在一个batch里对每个样本都dropout同样的操作，训练也会不稳定。因此对于不同的样本子集，作者dropout不同的操作：作者将一个batch的样本分成多个小batch（文中称为ghost batch），一个batch有1024个样本，分成32个ghost batch，每个有32个样本，每个ghost batch剔除不同的操作。</p>
</li>
<li><p>防止过度正则化。在训练期间，L2正则化只应用于当前结构在one-shot模型里所用到的那部分。如果不这样，那些经常被删除的层就会更加规范化。</p>
</li>
</ul>
<h2 id="4、评估和选择"><a href="#4、评估和选择" class="headerlink" title="4、评估和选择"></a><strong>4、评估和选择</strong></h2><p>当one-shot模型训练好之后，我们由一个固定的概率分布独立地采样结构，然后在验证集上评估。作者注意到，随机采样也可以的用遗传算法或基于神经网络的强化学习代替。完成搜索之后，从头训练表现最好的结构，同时也可以扩展架构以增加其性能，也可以缩小架构以减少计算成本。作者在实验中，增加了过滤器的数量来扩展架构。</p>
<h2 id="5、理解one-shot模型"><a href="#5、理解one-shot模型" class="headerlink" title="5、理解one-shot模型"></a><strong>5、理解one-shot模型</strong></h2><p>具体的实验细节、超参数和结果可参考原论文，这里讨论一下为什么固定的模型权重集合可以在不同的结构里共享。作者通过这篇论文实验和上篇的SMASH的实验发现，one-shot模型的准确率在30%至90%之间，或者10%至60%之间，但搜索到的独立模型的准确率在92%至94.5%之间，或者70%至75%之间，为什么one-shot模型的准确率之间相差这么多？</p>
<p>注意作者之前做了这样的假设：one-shot模型可以学习网络中哪些操作最有用，并在可用时依赖于这些操作，移除不重要的操作对模型预测的准确率有较小的影响，移除很重要的操作对模型预测的准确率有较大的影响。为了去验证这样的假设，作者采样了一批结构（参照结构），大部分操作没有被移除（$r=10^{-8}$）。作者将这些参考结构的预测与从实际搜索空间中采样的操作较少的候选结构的预测进行了比较，比较是在来自训练集的批样本上进行的。如果假设是正确的，那么由性能最佳的模型做出的预测与使能网络中的所有操作时做出的预测相似。</p>
<p>我们使用对称的KL散度来量化候选结构的预测与参考结构的预测的不同程度。one-shot模型用交叉熵损失函数，其输出是概率分布$(p_{1},p_{2}, \dots, p_{n})$，候选结构的输出概率分布为$(q_{1},q_{2}, \dots, q_{n})$，KL散度为$D_{KL}(p||q)=\sum_{i=1}^{n} p_{i} {\rm log}\frac{p_{i}}{q_{i}}$，对称KL散度为$D_{KL}(p||q)+D_{KL}(q||p)$。如果当前训练样本的分布几乎相同，则对称的KL散度将接近于0。相反，如果分布非常不同，对称的KL散度可以变化得得非常大。作者计算了64个随机样本的KL散度，并取了平均值。实验结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191018150908112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>训练集测得的KL散度与验证集测得的预测准确率有很强的相关性。此外，KL散度的计算没有用到训练集的标签。这意味着，候选体系结构的预测与参考体系结构的预测越接近（其中，one-shot模型中的大多数操作都是使能的），在独立模型训练期间，它的性能通常就越高。权重共享迫使one-shot模型识别并集中于对生成良好预测最有用的操作。</p>
<p>作者接下来展示了KL散度随着时间变化的趋势。作者采样了六个不同的结构然后观察随着训练它的KL散度的变化情况，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191018152641211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>一开始他们的K离散度是低的，因为模型的预测一开始置信度比较低，每类会分配一个大致相等的概率。随着训练，不同结构的预测开始变的不同，这导致了KL散度的激增，在训练后期，网络中最有用的操作对模型的预测有了强大的影响，KL散度开始下降。</p>
<h1 id="三、Single-path-one-shot-neural-architecture-search-with-uniform-sampling"><a href="#三、Single-path-one-shot-neural-architecture-search-with-uniform-sampling" class="headerlink" title="三、Single path one-shot neural architecture search with uniform sampling"></a><strong>三、Single path one-shot neural architecture search with uniform sampling</strong></h1><h2 id="1、总览-2"><a href="#1、总览-2" class="headerlink" title="1、总览"></a><strong>1、总览</strong></h2><p>大多数搜索空间松弛化的方法里，结构分布是被连续地参数化了，这些参数在超网络训练时一同被联合优化，因此结构搜索是在优化的过程中进行，优化结束后从结构分布中采样最好的结构。但这存在两个问题：（1）超网络里的参数是深度耦合的；（2）联合优化进一步引入了结构参数和超网络权重之间的耦合。梯度下降方法天生的贪婪特征会在结构分布和超网络权重中引入偏差，这可能会误导结构搜索。</p>
<p>one-shot方法为结构搜索提供了一个新的方向，并且没有结构松弛化和分布参数。结构搜索问题从超网络训练中解耦出来，变成一个单独的步骤，它结合了嵌套优化和联合优化方法的优点。刚才介绍的两篇论文就是这样的one-shot方法，解决了上面提到的第二个问题，但并没有很好地解决第一个问题，超网络的权重仍然是耦合的。在《Understanding and Simplifying One-Shot Architecture Search》里提到，one-shot成果的关键是一个使用权重继承的结构的准确率应该对已经优化好的结构有预测性。因此，作者提出超网络训练应该是随机的，所有的结构都可以同时优化它们的权重。为了减少超网络的权重耦合，作者提出了一个简单的搜索空间，单路径超网络（single path supernet）。对于超网络训练，作者采用均匀采样，平等地对待所有结构，没有超参数。</p>
<h2 id="2、NAS方法回顾"><a href="#2、NAS方法回顾" class="headerlink" title="2、NAS方法回顾"></a><strong>2、NAS方法回顾</strong></h2><p>我们用$\mathcal A$结构搜索空间，这是一个有向无环图（DAG），一个搜索到的结构是DAG的子图$a \in \mathcal A$，记为$\mathcal N(a,w)$，$w$为权重。NAS的目的是去解决两个有关联的问题，第一个是在标准深度学习里给定一个网络结构，优化其权重：</p>
<script type="math/tex; mode=display">
\begin{equation}
w_{a}=\underset{w}{\operatorname{argmin}} \mathcal{L}_{\text {train }}(\mathcal{N}(a, w))
\end{equation} \tag{1}</script><p>$\mathcal L_{train}(\cdot)$是在训练集上的损失函数。第二个问题是结构优化，一般来说是通过验证集的准确率来寻找：</p>
<script type="math/tex; mode=display">
\begin{equation}
a^{\ast}=\underset{a \in \mathcal A}{\operatorname{argmin}} {\rm ACC}_{\text {val }}(\mathcal{N}(a, w_{a})) \tag{2}
\end{equation}</script><p>${\rm ACC}_{\rm val}(\cdot)$是验证集准确率。真实情况下会对网络的内存消耗、FLOPs、latency、功耗等有要求，这些取决于结构$a$、软件和硬件等，但和权重$w_{a}$无关，因此作者称为“结构限制”。一个典型的限制网络的latency不大于预设的budget：</p>
<script type="math/tex; mode=display">
\begin{equation}
{\rm Latency(a^{\ast}) \leq {\rm Lat}_{\rm max}} \tag{3}
\end{equation}</script><p>对于大多数方法来说，同时满足式（2）和式（3）是很有挑战性的。最近的NAS方法采用了权值共享的策略，结构搜索空间$\mathcal A$被编码进一个超网络，记作$\mathcal N(\mathcal A, W)$，$W$是超网络的权重。超网络被训练一次，所有的结构都从$W$里直接继承，因此他们在相同的图节点上式共享权值的。大多权值共享的方法将离散的搜索空间转为连续的，$\mathcal A$松弛化为$\mathcal A(\theta)$，$\theta$为表示结构分布的连续化参数。注意新的空间包含了原始的搜索空间：$\mathcal A \subseteq \mathcal A(\theta)$。这样松弛化的好处是可以用梯度方法联合优化权重和结构分布参数，表示如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
\left(\theta^{*}, W_{\theta^{*}}\right)=\underset{\theta, W}{\operatorname{argmin}} \mathcal{L}_{t r a i n}(\mathcal{N}(\mathcal{A}(\theta), W)) \tag{4}
\end{equation}</script><p>优化后，最好的结构$a^{\ast}$从$\mathcal A(\theta)$采样得到，然后从$W_{\theta^{\ast}}$继承权值、微调。理论上这样做很合理，但优化式（4）是具有挑战性的。首先，在超网络里的图节点的权重是互相依赖的、深度耦合的，但从$W$中继承的权重解耦了，尚不明确为什么这样做是有效的。第二，联合训练结构参数$\theta$和权值$W$进一步引入了耦合。满足结构限制也是困难的，一些工作使用精心设计的soft损失项来扩充式(4)中的损失函数$\mathcal L_{train}$，但也很难满足像式（3）中的限制。作者总结了一下这部分提到的方法，连同作者提出的方法一同作了比较：<br><img src="https://img-blog.csdnimg.cn/20191021151840136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h2 id="3、one-shot-NAS-回顾"><a href="#3、one-shot-NAS-回顾" class="headerlink" title="3、one-shot NAS 回顾"></a><strong>3、one-shot NAS 回顾</strong></h2><p>通过上面的分析，耦合的结构搜索和权重优化是困难的，我们能否同时拥有问题解耦和权值共享的优点？这引出了叫做one-shot的方法（即上面解读的两篇论文），这两种方法依然训练一个超网络然后共享其中的参数，超网络训练和结构搜索是解耦成两个步骤，这既不同于嵌套式优化也不同于联合优化。首先，第一步优化超网络权重：</p>
<script type="math/tex; mode=display">
W_{\mathcal{A}}=\underset{W}{\operatorname{argmin}} \mathcal{L}_{\text {train }}(\mathcal{N}(\mathcal{A}, W)) \tag{5}</script><p>相比于式（4），搜索空间的连续化参数消失了，只有权重被优化。第二步，结构搜索表示为：</p>
<script type="math/tex; mode=display">
a^{*}=\underset{a \in \mathcal{A}}{\operatorname{argmax}} \mathrm{ACC}_{\mathrm{val}}\left(\mathcal{N}\left(a, W_{\mathcal{A}}(a)\right)\right) \tag{6}</script><p>在搜索过程中，每个采样的结构$a$从继承$W_{\mathcal A}$继承权重，记为$W_{\mathcal A}(a)$。同式（1）、式（2）相比，式（6）的主要不同是，结构的权重是合理初始化的，估计$ACC_{val}(\cdot)$只需推断，没有微调或重新训练。找到最优的结构$a^{\ast}$后，通过微调来获得$w_{a^{\ast}}$。这样的搜索也是灵活的，任何适当的搜索方法都可以，这里作者采用遗传算法。结构限制，式（3）的结构限制也被精确地满足。一旦训练好超网络，搜索可以用不同的结构限制（如100ms latency 和 200ms latency）在超网络上被重复很多次，之前的方法都没有这样的特性。但超网络的权重依然是耦合的。</p>
<h2 id="4、单路径超网络和均匀采样"><a href="#4、单路径超网络和均匀采样" class="headerlink" title="4、单路径超网络和均匀采样"></a><strong>4、单路径超网络和均匀采样</strong></h2><p>将式（1）作为理想的情况，one-shot要求权重$W_{\mathcal A}(a)$接近于最优权值$w_{a}$，近似的程度取决于训练损失$\mathcal L_{train}(\mathcal N(a, W_{\mathcal A}(a)))$被优化的程度。这引出一个原则，超网络的权重$W_{\mathcal A}$应该与搜索空间中的所有子结构的优化同时进行，如下式：</p>
<script type="math/tex; mode=display">
W_{\mathcal{A}}=\underset{W}{\operatorname{argmin}} \mathbb{E}_{a \sim \Gamma(\mathcal{A})}\left[\mathcal{L}_{\text {train }}(\mathcal{N}(a, W(a)))\right] \tag{7}</script><p>$\Gamma(\mathcal A)$是$a \in \mathcal A$的先验分布。注意，式（7）是式（5）的实现，在每步优化中，结构$a$是随机采样的，只有权重$W(a)$是被更新的。从这个意义上说，超级网络本身不再是一个有效的网络，它表现为一个随机超网络（stochastic supernet）。</p>
<p>为了较少权重之间的互相适应，作者建议将搜索空间简化到极限，只包含但路径结构，这可以看做是path dropout策略的极端情况，每次只保留一条路径，其他全部drop，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191021163132387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>它包括一系列的choice block，每个包含几个choices，每次只有一个choice被调用。这里不包含任何dorpout参数或微调。先验分布$\Gamma (\mathcal A)$可能是重要的，作者发现均匀采样已经足够好了。</p>
<h2 id="5、超网络和choice-block"><a href="#5、超网络和choice-block" class="headerlink" title="5、超网络和choice block"></a><strong>5、超网络和choice block</strong></h2><p>和《Understanding and Simplifying One-Shot Architecture Search》中的一样，choice block用于构建随机结构，一个choice block包含多个结构选择。对这里的但路径超网络，每次只有一个choice被调用，通过采样所有的choice block来获得一条路径。这里作者设计了两种choice block：</p>
<ul>
<li>通道数目搜索。这个choice block搜索一个卷积层的通道数目，它会预先分配一个最大通道数目的权重张量(max_c_out, max_c_in, ksize)，在超网络训练过程中，系统随机选择当前输出通道数目$c_out$，然后从其中切片出张量子集$[:c_out, : c_in, :]$，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191021164338551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li>
<li>混合精度量化搜索。这个choice block用于搜索卷积层的权值和特征的量化精度。在超网络训练过程中，特征图的位宽和滤波器权值是随机选择的，如下图所示：<br><img src="https://img-blog.csdnimg.cn/2019102116462811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><h2 id="6、进化结构搜索"><a href="#6、进化结构搜索" class="headerlink" title="6、进化结构搜索"></a><strong>6、进化结构搜索</strong></h2>对于式（6）的结构搜索，前面两篇论文使用随机搜索，而作者使用遗传算法，算法伪代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191021164915185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>对于所有的实验，种群大小$P=50$，最大迭代次数$\mathcal T=20$，$k=10$，对于交叉，随机选择两个候选结构去交叉生成一个新的结构，对于变异，在每个choice block以0.1的概率从候选变异中随机选择一种变异，产生一个新的结构。在对结构进行推断之前，BN的统计量从训练集中随机选择子集样本重新计算，因为超网络的BN统计量一般来说并不适合于候选结构。</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><p>[1] Brock A , Lim T , Ritchie J M , et al. SMASH: One-Shot Model Architecture Search through HyperNetworks[J]. 2017.<br>[2] Bender, Gabriel, et al. “Understanding and simplifying one-shot architecture search.” International Conference on Machine Learning. 2018.<br>[3] Guo, Zichao, et al. “Single path one-shot neural architecture search with uniform sampling.” arXiv preprint arXiv:1904.00420 (2019).<br>[4] <a href="https://www.jiqizhixin.com/articles/2019-04-02-8" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2019-04-02-8</a><br>[5] 《深入理解AutoML和AutoDL》</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/原创教程/">原创教程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/深度学习/">深度学习</a>
                    
                      <a class="hover-with-bg" href="/tags/自动化/">自动化</a>
                    
                      <a class="hover-with-bg" href="/tags/NAS/">NAS</a>
                    
                      <a class="hover-with-bg" href="/tags/AutoDL/">AutoDL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/12/13/读AutoDL论文——SCARLET-NAS/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">读AutoDL论文——SCARLET-NAS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/10/15/AutoDL论文解读（六）：基于代理模型的NAS/">
                        <span class="hidden-mobile">AutoDL论文解读（六）：基于代理模型的NAS</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "4uTKUSHbisxPDbqazfBvQyvM-gzGzoHsz",
          app_key: "KBjTdSy7b9V1AlRMP3GpweuD",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" rel="nofollow noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">京ICP证20022949号</a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="/js/debouncer.js"></script>
<script src="/js/main.js"></script>

<!-- Plugins -->


  
    <script src="/js/lazyload.js"></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script>
  <script src="/js/clipboard-use.js"></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2019/10/21/AutoDL论文解读（七）：基于one-shot的NAS/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = '4uTKUSHbisxPDbqazfBvQyvM-gzGzoHsz'
    var app_key = 'KBjTdSy7b9V1AlRMP3GpweuD'
    var server_url = 'https://4utkushb.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js"></script>

  



  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  











  

  

  

  

  

  





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
	extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
